; svn $Id$
;+
; CLASS:
;   MGH_GUI_Testbed
;
; CATEGORY:
;       Widgets.
;
; PURPOSE:
;   A testbed for widget components. Handy for examining events generated by
;   widget components and an example of how to extend MGH_GUI_Base.
;
; OBJECT CREATION SEQUENCE:
;   Create an 'MGH_GUI_Testbed' object with a single button.
;
;     obed = obj_new('MGH_GUI_Testbed')
;     obed->Test
;
;   Create an 'MGH_GUI_Testbed' object with a single button.
;
;   Create an 'MGH_GUI_Testbed' object and add a child widget by
;   calling function 'func'
;
;     obed = obj_new('MGH_GUI_Testbed')
;     obed->Test, func
;
;   Create an 'MGH_GUI_Testbed' object and add a child widget by
;   creating class 'class' (assumed to be a subclass of MGH_GUI_Base).
;   Call the testbed object's Update method to ensure all children
;   are updated.
;
;     obed = obj_new('MGH_GUI_Testbed')
;     obed->Test, class, /OBJECT
;     obed->Update
;
;   The testbed's Init method accepts the same keywords as MGH_GUI_Base.
;   The testbed's Test method accepts additional arguments (up to 3) and
;   keywords that are passed to the child widget.
;
;###########################################################################
;
; This software is provided subject to the following conditions:
;
; 1.  NIWA makes no representations or warranties regarding the
;     accuracy of the software, the use to which the software may
;     be put or the results to be obtained from the use of the
;     software.  Accordingly NIWA accepts no liability for any loss
;     or damage (whether direct of indirect) incurred by any person
;     through the use of or reliance on the software.
;
; 2.  NIWA is to be acknowledged as the original author of the
;     software where the software is used or presented in any form.
;
;###########################################################################
;
; MODIFICATION HISTORY:
;   Mark Hadfield, 2001-06:
;     Written.
;   Mark Hadfield, 2001-10:
;     * Increased maximum number of arguments to 3 to accommodate
;     CW_ANIMATE.
;     * Updated for IDL 5.5.
;   Mark Hadfield, 2002-07:
;     Creation of test widget now done in the Test method, not in the
;     testbed's Init method. I have made this change for the usual
;     reason: when test widget creation was done in the Init method
;     I got into a tangle in interpreting keywords and arguments
;-


; MGH_GUI_Testbed::Init
;
function MGH_GUI_Testbed::Init, widget, arg0, arg1, arg2, _REF_EXTRA=extra

   compile_opt DEFINT32
   compile_opt STRICTARR
   compile_opt STRICTARRSUBS
   compile_opt LOGICAL_PREDICATE


   ok = self->MGH_GUI_Base::Init(/COLUMN, /BASE_ALIGN_CENTER, $
                                 TLB_FRAME_ATTR=1, TITLE='IDL Widget Testbed', $
                                 _STRICT_EXTRA=extra)
   if ~ ok then $
        message, BLOCK='MGH_MBLK_MOTLEY', NAME='MGH_M_INITFAIL', 'MGH_GUI_Base'

   self->BuildTestBase

   self->BuildButtonBar

   self->Finalize, 'MGH_GUI_Testbed'

   return, 1

end

; MGH_GUI_Testbed::GetProperty
;
pro MGH_GUI_Testbed::GetProperty, $
     TEST_ID=test_id, TEST_OBJ=test_obj, _REF_EXTRA=extra

   compile_opt DEFINT32
   compile_opt STRICTARR
   compile_opt STRICTARRSUBS
   compile_opt LOGICAL_PREDICATE


   test_id = self.test_base->FindChild('TEST')

   test_obj = mgh_widget_self(test_id)

   self->MGH_GUI_Base::GetProperty, _STRICT_EXTRA=extra

end


; MGH_GUI_Testbed::About
;
;   Print information about the object.
;
pro MGH_GUI_Testbed::About, lun

   compile_opt DEFINT32
   compile_opt STRICTARR
   compile_opt STRICTARRSUBS
   compile_opt LOGICAL_PREDICATE


   self->MGH_GUI_Base::About, lun

   self->GetProperty, TEST_ID=test_id, TEST_OBJ=test_obj

   printf, lun, self, ': The test widget is rooted at '+strtrim(test_id,2)

   if obj_valid(test_obj) then $
        printf, lun, self, ': The test widget object is ', test_obj

end

; MGH_GUI_Testbed::BuildButtonBar
;
pro MGH_GUI_Testbed::BuildButtonBar

   compile_opt DEFINT32
   compile_opt STRICTARR
   compile_opt STRICTARRSUBS
   compile_opt LOGICAL_PREDICATE


   self->NewChild, 'mgh_gui_base', /OBJECT, /ALIGN_CENTER, $
        /BASE_ALIGN_CENTER, /ROW, SPACE=10, $
        UVALUE=self->Callback('EventButtonBar'), RESULT=obar

   obar->NewChild, 'widget_button', VALUE='Close', UNAME='Close', TOOLTIP='Close testbed application'

end

; MGH_GUI_Testbed::BuildTestBase
;
pro MGH_GUI_Testbed::BuildTestBase

   compile_opt DEFINT32
   compile_opt STRICTARR
   compile_opt STRICTARRSUBS
   compile_opt LOGICAL_PREDICATE


   ;; Add a child base to put the test widget on. Events from the base
   ;; & all its children are wrapped and sent to EventTestBase.

   self->NewChild, /OBJECT, 'mgh_gui_base', $
        /ROW, XPAD=50, YPAD=50, /CONTEXT_EVENTS, /FRAME, PROCESS_EVENTS=0, $
        UVALUE=self->Callback('EventTestBase'), RESULT=otbase
   self.test_base = otbase


end

; MGH_GUI_Testbed::EventButtonBar
;
function MGH_GUI_Testbed::EventButtonBar, event

   compile_opt DEFINT32
   compile_opt STRICTARR
   compile_opt STRICTARRSUBS
   compile_opt LOGICAL_PREDICATE


   case event.uname of

      'Close': begin
         self->Kill
         return, 0
      end

      else: return, self->EventUnexpected(event)

   endcase

end

; MGH_GUI_Testbed::EventTestBase
;
function MGH_GUI_Testbed::EventTestBase, event

   compile_opt DEFINT32
   compile_opt STRICTARR
   compile_opt STRICTARRSUBS
   compile_opt LOGICAL_PREDICATE


   case tag_names(event, /STRUCTURE_NAME) of

      'WIDGET_CONTEXT': begin
         widget_displaycontextmenu, event.id, event.x, event.y, self.test_context
         return, 0
      end

      else: return, EventUnexpected(event)

   endcase

end

; MGH_GUI_Testbed::EventTestContext
;
function MGH_GUI_Testbed::EventTestContext, event

   compile_opt DEFINT32
   compile_opt STRICTARR
   compile_opt STRICTARRSUBS
   compile_opt LOGICAL_PREDICATE


   case event.value of

      'ABOUT TESTBED': begin
         self->About
         return, 0
      end

      'ABOUT TEST WIDGET': begin
         self->GetProperty, TEST_OBJ=test_obj
         if obj_valid(test_obj) then test_obj->About
         return, 0
      end

      'EXPORT INFO': begin
         self->GetProperty, TEST_ID=test_id, TEST_OBJ=test_obj
         labels = 'Test Widget ID'
         values = ptr_new(test_id)
         if obj_valid(test_obj) then begin
            labels = [labels, 'Test Widget Obj']
            values = [values, ptr_new(test_obj)]
         endif
         ogui =obj_new('MGH_GUI_Export', values, labels, /BLOCK, /FLOATING, $
                       GROUP_LEADER=self.base)
         ogui->Manage
         obj_destroy, ogui
         return, 0
      end

      else: return, self->EventUnexpected(event)

   endcase

end


; MGH_GUI_Testbed::EventTestWidget
;
function MGH_GUI_Testbed::EventTestWidget, event

   compile_opt DEFINT32
   compile_opt STRICTARR
   compile_opt STRICTARRSUBS
   compile_opt LOGICAL_PREDICATE


   print, 'Event from test widget:'
   help, /STRUCT, event
   return, 0

end



; MGH_GUI_Testbed::Test
;
pro MGH_GUI_Testbed::Test, widget, arg0, arg1, arg2, RESULT=result, _REF_EXTRA=extra

   compile_opt DEFINT32
   compile_opt STRICTARR
   compile_opt STRICTARRSUBS
   compile_opt LOGICAL_PREDICATE


   if ~ obj_valid(self.test_base) then $
        message, 'Test base is not valid'

   self->GetProperty, TEST_ID=test_id

   if widget_info(test_id, /VALID_ID) then $
        message, 'A test widget already exists'

   ;; Create the test widget

   otbase = self.test_base

   case n_params() of
      0: begin
         otbase->NewChild, RESULT=result, 'widget_button', UNAME='TEST', $
              UVALUE=self->Callback('EventTestWidget'), VALUE='Hello world', $
              XSIZE=100, YSIZE=100, TOOLTIP='Press me', _STRICT_EXTRA=extra
      end
      1: begin
         otbase->NewChild, widget, UNAME='TEST', $
              UVALUE=self->Callback('EventTestWidget'), $
              _STRICT_EXTRA=extra, RESULT=result
      end
      2: begin
         otbase->NewChild, widget, arg0, UNAME='TEST', $
              UVALUE=self->Callback('EventTestWidget'), $
              _STRICT_EXTRA=extra, RESULT=result
      end
      3: begin
         otbase->NewChild, widget, arg0, arg1, UNAME='TEST', $
              UVALUE=self->Callback('EventTestWidget'), $
              _STRICT_EXTRA=extra, RESULT=result
      end
      4: begin
         otbase->NewChild, widget, arg0, arg1, arg2, UNAME='TEST', $
              UVALUE=self->Callback('EventTestWidget'), $
              _STRICT_EXTRA=extra, RESULT=result
      end
   endcase

   ;; Create a context menu for the base.

   case obj_valid(result) of
      0: begin
         otbase->NewChild, /OBJECT, 'MGH_GUI_PDmenu', /CONTEXT, $
              ['About Testbed','Export Info'], UNAME='CONTEXT', $
              UVALUE=self->Callback('EventTestContext'), RESULT=omenu
      end
      1: begin
         otbase->NewChild, /OBJECT, 'MGH_GUI_PDmenu', /CONTEXT, $
              ['About Testbed','About Test Widget','Export Info'], UNAME='CONTEXT', $
              UVALUE=self->Callback('EventTestContext'), RESULT=omenu
      end
   endcase
   self.test_context =  omenu->GetBase()

end

; MGH_GUI_Testbed::Update
;
pro MGH_GUI_Testbed::Update

   compile_opt DEFINT32
   compile_opt STRICTARR
   compile_opt STRICTARRSUBS
   compile_opt LOGICAL_PREDICATE


   self->GetProperty, TEST_OBJ=test_obj

   if obj_valid(test_obj) then test_obj->Update

end


; MGH_GUI_Testbed__Define
;
pro MGH_GUI_Testbed__Define

   compile_opt DEFINT32
   compile_opt STRICTARR
   compile_opt STRICTARRSUBS
   compile_opt LOGICAL_PREDICATE


   struct_hide, {MGH_GUI_Testbed, inherits MGH_GUI_Base, $
                 test_base: obj_new(), test_context: 0L}

end


